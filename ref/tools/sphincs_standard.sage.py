

# This file was *autogenerated* from the file sphincs_standard.sage
from sage.all_cmdline import *   # import sage library

_sage_const_66 = Integer(66); _sage_const_2 = Integer(2); _sage_const_64 = Integer(64); _sage_const_9 = Integer(9); _sage_const_64000 = Integer(64000); _sage_const_4 = Integer(4); _sage_const_100 = Integer(100); _sage_const_128 = Integer(128); _sage_const_8 = Integer(8); _sage_const_1 = Integer(1); _sage_const_68 = Integer(68); _sage_const_57 = Integer(57); _sage_const_17 = Integer(17); _sage_const_16 = Integer(16); _sage_const_22 = Integer(22); _sage_const_20 = Integer(20); _sage_const_35 = Integer(35); _sage_const_33 = Integer(33); _sage_const_6 = Integer(6)# Set variables in the following three lines
tsec        = _sage_const_128     # Pr[one attacker hash call works] <= 1/2^tsec
maxsigs     = _sage_const_2 **_sage_const_64    # at most 2^72
maxsigbytes = _sage_const_64000   # Don't print parameters if signature size is larger
#### Don't edit below this line ####

#### Generic caching layer to save time

import collections
class memoized(object):
  def __init__(self,func):
    self.func = func
    self.cache = {}
    self.__name__ = 'memoized:' + func.__name__
  def __call__(self,*args):
    if not isinstance(args,collections.Hashable):
      return self.func(*args)
    if not args in self.cache:
      self.cache[args] = self.func(*args)
    return self.cache[args]

#### SPHINCS+ analysis

F = RealIntervalField(tsec+_sage_const_100 )
sigmalimit = F(_sage_const_2 **(-tsec))
donelimit  = _sage_const_1 -sigmalimit/_sage_const_2 **_sage_const_20 
hashbytes  = tsec/_sage_const_8  # length of hashes in bytes

# Pr[exactly r sigs hit the leaf targeted by this forgery attempt]
@memoized
def qhitprob(leaves,qs,r):
    p = _sage_const_1 /F(leaves)
    return binomial(qs,r)*p**r*(_sage_const_1 -p)**(qs-r)

# Pr[FORS forgery given that exactly r sigs hit the leaf] = (1-(1-1/F(2^b))^r)^k
@memoized
def forgeryprob(b,r,k):
    if k == _sage_const_1 : return _sage_const_1 -(_sage_const_1 -_sage_const_1 /F(_sage_const_2 **b))**r
    return forgeryprob(b,r,_sage_const_1 )*forgeryprob(b,r,k-_sage_const_1 )

# Number of WOTS chains
@memoized
def wotschains(m,w):
    la = ceil(m / log(w,_sage_const_2 ))
    return la + floor(log(la*(w-_sage_const_1 ), _sage_const_2 ) / log(w,_sage_const_2 )) + _sage_const_1 


def compute_size_speed(h, d, b, k, w):
  # h = Height of the hypertree
  # d = number of layers in hypertree
  # b = height of a tree in FORS (log2(t))
  # k = number of trees in hypertree
  # w = winternitz parameter
  wots = wotschains(_sage_const_8 *hashbytes,w)
  sigsize = ((b+_sage_const_1 )*k+h+wots*d+_sage_const_1 )*hashbytes
  speed   = k*_sage_const_2 **(b+_sage_const_1 ) + d*(_sage_const_2 **(h/d)*(wots*w+_sage_const_1 ))  # Rough speed estimate based on #hashes

  return sigsize, speed


param_sets = {
  "sphincs-128f": (_sage_const_66 , _sage_const_22 , _sage_const_6 , _sage_const_33 , _sage_const_16 ),
  "sphincs-128f-8 4 6 57 16 10": (_sage_const_8 , _sage_const_4 , _sage_const_6 , _sage_const_57 , _sage_const_16 ),
  "sphincs-192f": (_sage_const_66 , _sage_const_22 , _sage_const_8 , _sage_const_33 , _sage_const_16 ),
  "sphincs-256f": (_sage_const_68 , _sage_const_17 , _sage_const_9 , _sage_const_35 , _sage_const_16 ),
}

for param in param_sets:
  size, speed = compute_size_speed(*param_sets[param])
  print("%s: size=%s,speed=%s" % (param, size, speed))


