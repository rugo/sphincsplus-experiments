

# This file was *autogenerated* from the file sphincs.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_100 = Integer(100); _sage_const_256 = Integer(256); _sage_const_8 = Integer(8); _sage_const_30000 = Integer(30000); _sage_const_64 = Integer(64); _sage_const_16 = Integer(16); _sage_const_20 = Integer(20); _sage_const_128 = Integer(128); _sage_const_24 = Integer(24)# Set variables in the following three lines
tsec        = _sage_const_256     # Pr[one attacker hash call works] <= 1/2^tsec
maxsigs     = _sage_const_2 **_sage_const_8    # at most 2^72
maxsigbytes = _sage_const_30000   # Don't print parameters if signature size is larger
#### Don't edit below this line ####

#### Generic caching layer to save time

import collections
class memoized(object):
  def __init__(self,func):
    self.func = func
    self.cache = {}
    self.__name__ = 'memoized:' + func.__name__
  def __call__(self,*args):
    if not isinstance(args,collections.Hashable):
      return self.func(*args)
    if not args in self.cache:
      self.cache[args] = self.func(*args)
    return self.cache[args]

#### SPHINCS+ analysis

F = RealIntervalField(tsec+_sage_const_100 )
sigmalimit = F(_sage_const_2 **(-tsec))
donelimit  = _sage_const_1 -sigmalimit/_sage_const_2 **_sage_const_20 
hashbytes  = tsec/_sage_const_8  # length of hashes in bytes

# Pr[exactly r sigs hit the leaf targeted by this forgery attempt]
@memoized
def qhitprob(leaves,qs,r):
    p = _sage_const_1 /F(leaves)
    return binomial(qs,r)*p**r*(_sage_const_1 -p)**(qs-r)

# Pr[FORS forgery given that exactly r sigs hit the leaf] = (1-(1-1/F(2^b))^r)^k
@memoized
def forgeryprob(b,r,k):
    if k == _sage_const_1 : return _sage_const_1 -(_sage_const_1 -_sage_const_1 /F(_sage_const_2 **b))**r
    return forgeryprob(b,r,_sage_const_1 )*forgeryprob(b,r,k-_sage_const_1 )

# Number of WOTS chains
@memoized
def wotschains(m,w):
    la = ceil(m / log(w,_sage_const_2 ))
    return la + floor(log(la*(w-_sage_const_1 ), _sage_const_2 ) / log(w,_sage_const_2 )) + _sage_const_1 

s = log(maxsigs,_sage_const_2 )
for h in range(s-_sage_const_8 ,s+_sage_const_20 ):                                             # Iterate over total tree height
    leaves = _sage_const_2 **h
    for b in range(_sage_const_3 ,_sage_const_24 ):                                             # Iterate over height of FORS trees
        for k in range(_sage_const_1 ,_sage_const_128 ):                                         # Iterate over number of FORS trees
            sigma = _sage_const_0 
            r = _sage_const_1 
            done = qhitprob(leaves,maxsigs,_sage_const_0 )
            while done < donelimit:
                t = qhitprob(leaves,maxsigs,r)
                sigma += t*forgeryprob(b,r,k)
                if sigma > sigmalimit: break
                done  += t
                r     += _sage_const_1 
            sigma += min(_sage_const_0 ,_sage_const_1 -done)
            if sigma > sigmalimit: continue
            sec = ceil(log(sigma,_sage_const_2 ))
            for d in range(_sage_const_4 ,h):                                      # Iterate over number of sub-trees
                if h % d == _sage_const_0  and h <= _sage_const_64 +(h/d):
                    for w in [_sage_const_4 , _sage_const_16 , _sage_const_256 ]:                                # Try different Winternitz parameters
                        wots = wotschains(_sage_const_8 *hashbytes,w)
                        sigsize = ((b+_sage_const_1 )*k+h+wots*d+_sage_const_1 )*hashbytes
                        speed   = k*_sage_const_2 **(b+_sage_const_1 ) + d*(_sage_const_2 **(h/d)*(wots*w+_sage_const_1 ))  # Rough speed estimate based on #hashes
                        if sigsize < maxsigbytes and -sec < _sage_const_2 *tsec:
                           # print(h,d,b,k,w,sec,sigsize,speed)                          # SPHINCS+ parameters
                           print("\t".join(map(str, (sigsize, speed, _sage_const_0 , sec, h,d,b,k,w, _sage_const_0 ))))
                           # print(sec)                                # FORS forgery probability
                           # print(sigsize)                            # Sig size in bytes
                           # print(speed)                               # Signing speed estimate (based on #hashes)

